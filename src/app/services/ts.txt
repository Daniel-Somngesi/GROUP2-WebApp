

1.  ng g s services/question



import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

const baseUrl = 'https://localhost:44341/api/Question';

@Injectable({
  providedIn: 'root'
})
export class QuestionService {

  constructor(private http: HttpClient) { }
  getAll(): Observable<any> {
    return this.http.get(baseUrl);
  }

  get(id:any): Observable<any> {
    return this.http.get(`${baseUrl}/${id}`);
  }

  create(data:any): Observable<any> {
    return this.http.post(baseUrl, data);
  }

  update(id:any, data:any): Observable<any> {
    return this.http.put(`${baseUrl}/${id}`, data);
  }

  delete(id:any): Observable<any> {
    return this.http.delete(`${baseUrl}/${id}`);
  }
}



2.   ng g c components/question/question-list


import { QuestionService } from './../../../services/question.service';
import { Component, OnInit } from '@angular/core';
import { FormBuilder, Validators } from '@angular/forms';
import { MatSnackBar, MatSnackBarHorizontalPosition, MatSnackBarVerticalPosition } from '@angular/material/snack-bar';
import { ActivatedRoute } from '@angular/router';
import { QuestionData } from 'src/app/Interface/Interface';

@Component({
  selector: 'app-question-list',
  templateUrl: './question-list.component.html',
  styleUrls: ['./question-list.component.css']
})
export class QuestionListComponent implements OnInit {

  questionForm:any;
  questions:any;
  horizontalPosition: MatSnackBarHorizontalPosition = 'center';
  verticalPosition: MatSnackBarVerticalPosition = 'bottom';
  currentQuestion:any = null;
  questionIdUpdate = null;
  question_Id = null;
  question_Text : string = "";

  constructor(private route: ActivatedRoute, private formbulider: FormBuilder, private service: QuestionService, private _snackBar: MatSnackBar) { }

  ngOnInit(): void {
    this.retrieveQuestions();
    this.questionForm = this.formbulider.group({
      question_Text: ['', [Validators.required, Validators.maxLength(200)]],
    });
  }

  retrieveQuestions(): void {
    this.service.getAll()
      .subscribe(
        data => {
          this.questions = data;
        },
        error => {
          console.log(error);
        });
      }

      onFormSubmit() {
        const _question = this.questionForm.value;
        this.CreateQuestion(_question);
      }

      loadQuestionToEdit(question_Id:any) {
        this.service.get(question_Id).subscribe(question => {
          this.questionIdUpdate = question.question_Id;
          this.questionForm.controls['question_Text'].setValue(question.question_Text);

        });
    }

      deleteQuestion(id: any) {
        if (confirm("Are you sure you want to delete this question?")) {
          this.service.delete(id).subscribe(() => {
            this.SavedSuccessful(2);
            this.retrieveQuestions();
            this.questionForm.reset();

          });
        }
      }

      CreateQuestion(question: QuestionData) {
        if (this.questionIdUpdate == null) {

          this.service.create(question).subscribe(
            () => {
              this.SavedSuccessful(1);
              this.retrieveQuestions();
              this.questionIdUpdate = null;
              this.questionForm.reset();
            }
          );
        } else {
          question.question_Id = this.questionIdUpdate;
          question.question_Text = this.question_Text;
          this.service.update(question.question_Id, question).subscribe(() => {
            this.SavedSuccessful(0);
            this.retrieveQuestions();
            this.questionIdUpdate = null;
            this.questionForm.reset();
          });
        }
      }

      SavedSuccessful(isUpdate:any) {
        if (isUpdate == 0) {
          this._snackBar.open('Record Updated Successfully!', 'Close', {
            duration: 2000,
            horizontalPosition: this.horizontalPosition,
            verticalPosition: this.verticalPosition,
          });
        }
        else if (isUpdate == 1) {
          this._snackBar.open('Record Saved Successfully!', 'Close', {
            duration: 2000,
            horizontalPosition: this.horizontalPosition,
            verticalPosition: this.verticalPosition,
          });
        }
        else if (isUpdate == 2) {
          this._snackBar.open('Record Deleted Successfully!', 'Close', {
            duration: 2000,
            horizontalPosition: this.horizontalPosition,
            verticalPosition: this.verticalPosition,
          });
        }
      }
    }



3. html


<h1>Survey Questions</h1>

<form [formGroup]="questionForm" (ngSubmit)="onFormSubmit()">
  <mat-form-field class="demo-full-width">
    <input class="form-control" formControlName="question_Text" pattern="[a-zA-Z ]*" [(ngModel)]="question_Text" matTooltip="Enter question" matInput placeholder="Type question" autocomplete="off" required>
  </mat-form-field>
<br>

  <mat-error>
    <span *ngIf="!questionForm.get('question_Text').value && questionForm.get('question_Text').touched"></span>

  </mat-error>

<button type="submit" mat-raised-button [disabled]="!questionForm.valid" color="accent" matTooltip="Submit">Submit</button>
  </form>

  <div >
    <h2>Questions</h2>
    <ol>
     <ng-container *ngFor="let q of questions; let i=index">
        <li>{{q.question_Text}}<button id="btnDelete" mat-mini-fab color="primary" mat-raised-button color="accent" matTooltip="Delete" aria-label="Example icon button with a delete icon" (click)="deleteQuestion(q.question_Id)">
          <mat-icon>delete</mat-icon></button><button mat-mini-fab mat-raised-button aria-label="Example icon button with a vertical three dot icon" type="button" mat-raised-button color="accent" matTooltip="Edit" (click)="loadQuestionToEdit(q.question_Id )">
            <mat-icon>edit</mat-icon></button>
           </li>

     </ng-container>
    </ol>
  </div>



4. CSS

li {
  background-color:rgba(181, 250, 227, 0.61);
  font-weight: bolder;
  font-size: large;
  border-bottom: 2px solid black;
  margin-bottom: 10px;
}






